From ddbebd6165eb7b693e2a101a105796ace9e95be1 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Tue, 25 Dec 2018 16:20:35 +0800
Subject: [PATCH 29/30] waylandsink: Enable changing window handle

Changing window handle is dangerous, but we need this feature for:
https://redmine.rockchip.com.cn/issues/184629

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 ext/wayland/gstwaylandsink.c | 19 ++++++++++++-------
 ext/wayland/gstwaylandsink.h |  1 +
 2 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 78dd294..0f9bcf5 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -652,9 +652,10 @@ render_last_buffer (GstWaylandSink * sink, gboolean redraw)
   callback = wl_surface_frame (surface);
   wl_callback_add_listener (callback, &frame_callback_listener, sink);
 
-  if (G_UNLIKELY (sink->video_info_changed && !redraw)) {
+  if (G_UNLIKELY ((sink->video_info_changed && !redraw) || sink->resend_info)) {
     info = &sink->video_info;
     sink->video_info_changed = FALSE;
+    sink->resend_info = FALSE;
   }
   gst_wl_window_render (sink->window, wlbuffer, info);
 }
@@ -917,18 +918,16 @@ gst_wayland_sink_set_window_handle (GstVideoOverlay * overlay, guintptr handle)
 
   g_return_if_fail (sink != NULL);
 
+  g_mutex_lock (&sink->render_lock);
+
   if (sink->window != NULL) {
-    GST_WARNING_OBJECT (sink, "changing window handle is not supported");
-    return;
+    GST_WARNING_OBJECT (sink, "changing window handle is dangerous");
+    g_clear_object (&sink->window);
   }
 
-  g_mutex_lock (&sink->render_lock);
-
   GST_DEBUG_OBJECT (sink, "Setting window handle %" GST_PTR_FORMAT,
       (void *) handle);
 
-  g_clear_object (&sink->window);
-
   if (handle) {
     if (G_LIKELY (gst_wayland_sink_find_display (sink))) {
       /* we cannot use our own display with an external window handle */
@@ -941,6 +940,12 @@ gst_wayland_sink_set_window_handle (GstVideoOverlay * overlay, guintptr handle)
       } else {
         sink->window = gst_wl_window_new_in_surface (sink->display, surface,
             &sink->render_lock);
+
+        if (sink->last_buffer) {
+          /* Resend video info to force resize video surface */
+          sink->resend_info = TRUE;
+          sink->redraw_pending = FALSE;
+        }
       }
     } else {
       GST_ERROR_OBJECT (sink, "Failed to find display handle, "
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
index be92fe7..31d4644 100644
--- a/ext/wayland/gstwaylandsink.h
+++ b/ext/wayland/gstwaylandsink.h
@@ -64,6 +64,7 @@ struct _GstWaylandSink
 
   gchar *display_name;
 
+  gboolean resend_info;
   gboolean redraw_pending;
   GMutex render_lock;
   GstBuffer *last_buffer;
-- 
2.11.0

